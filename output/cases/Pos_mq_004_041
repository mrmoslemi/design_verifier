mtype = {
	posState_working,
	posState_idle,
	posState_failed,
	posState_paid,
	produceTimer_timeout,
	produceTimer_running,
	controllerState_select,
	controllerState_pos,
	controllerState_take,
	controllerState_produce,
	doorLock_lock,
	doorLock_unlock
};
chan posState_cout = [0] of {mtype};

chan produceTimer_cin = [0] of {mtype};

chan controllerState_cin = [0] of {mtype};

chan doorLock_cin = [0] of {mtype};

chan posState_cin = [0] of {mtype};

mtype posState=posState_idle;
mtype produceTimer=produceTimer_timeout;
int produceTimer_value=0;
mtype controllerState=controllerState_select;
mtype doorLock=doorLock_lock;


active proctype Pos(){
	do
	:: controllerState_cin?controllerState_select -> controllerState=controllerState_select;
	:: controllerState_cin?controllerState_pos -> controllerState=controllerState_pos;
		if
		// TRANSITION POS_SRS_1
		:: ((controllerState == controllerState_pos)) -> posState_cout!posState_working; 
		fi;
	:: controllerState_cin?controllerState_take -> controllerState=controllerState_take;
	:: controllerState_cin?controllerState_produce -> controllerState=controllerState_produce;
	:: posState_cin?posState_working -> posState=posState_working;
	:: posState_cin?posState_idle -> posState=posState_idle;
	:: posState_cin?posState_failed -> posState=posState_failed;
	:: posState_cin?posState_paid -> posState=posState_paid;
	// NO TRIG TRANSITION POS_SRS_2
	:: ((posState == posState_working)) -> posState_cout!posState_paid; 
	// NO TRIG TRANSITION POS_SRS_3
	:: ((posState == posState_working)) -> posState_cout!posState_failed; 
	od;
};

active proctype UniversalEnvironment(){
do
	::posState_cout?posState_working -> posState_cin!posState_working;
	::posState_cout?posState_failed -> posState_cin!posState_failed;
	::posState_cout?posState_paid -> posState_cin!posState_paid;
	::posState_cout?posState_idle -> posState_cin!posState_idle;
od;
}
trace{
	Q_0: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_0;
		::controllerState_cin?controllerState_pos -> goto Q_0;
		::doorLock_cin?doorLock_lock -> goto Q_0;
		::controllerState_cin?controllerState_select -> goto Q_0;
		::produceTimer_cin?produceTimer_timeout -> goto Q_2;
		::controllerState_cin?controllerState_produce -> goto Q_0;
	fi;
	Q_1: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_1;
		::controllerState_cin?controllerState_pos -> goto Q_1;
		::doorLock_cin?doorLock_lock -> goto Q_0;
		::controllerState_cin?controllerState_select -> goto Q_1;
		::controllerState_cin?controllerState_produce -> goto Q_1;
	fi;
	Q_2: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_2;
		::controllerState_cin?controllerState_pos -> goto Q_2;
		::controllerState_cin?controllerState_select -> goto Q_2;
		::controllerState_cin?controllerState_produce -> goto Q_2;
	fi;

}
active proctype word(){
	doorLock_cin!doorLock_unlock;
	controllerState_cin!controllerState_take;
	doorLock_cin!doorLock_lock;
	produceTimer_cin!produceTimer_timeout;
	doorLock_cin!doorLock_lock;
	controllerState_cin!controllerState_select;
	doorLock_cin!doorLock_lock;

}
active proctype UnmatchedActions(){end: do
	:: doorLock_cin?doorLock_unlock;
	:: doorLock_cin?doorLock_lock;
	:: produceTimer_cin?produceTimer_timeout;
od;
}
