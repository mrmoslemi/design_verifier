mtype = {
	produceTimer_timeout,
	produceTimer_running,
	controllerState_select,
	controllerState_pos,
	controllerState_take,
	controllerState_produce,
	producerState_producing,
	producerState_full,
	producerState_empty,
	action_take,
	action_selectAmericano,
	action_selectLatte,
	action_selectMocha,
	action_selectEspresso,
	action_ok,
	action_cancel,
	doorLock_lock,
	doorLock_unlock
};
chan action_cin = [0] of {mtype};

chan produceTimer_cin = [0] of {mtype};

chan producerState_cin = [0] of {mtype};

chan produceTimer_cout = [0] of {mtype};

chan controllerState_cin = [0] of {mtype};

chan doorLock_cin = [0] of {mtype};

chan producerState_cout = [0] of {mtype};

chan doorLock_cout = [0] of {mtype};

mtype produceTimer=produceTimer_timeout;
int produceTimer_value=0;
mtype controllerState=controllerState_select;
mtype producerState=producerState_empty;
mtype action=action_ok;
mtype doorLock=doorLock_lock;


active proctype Producer(){
	do
	:: controllerState_cin?controllerState_select -> controllerState=controllerState_select;
	:: controllerState_cin?controllerState_pos -> controllerState=controllerState_pos;
	:: controllerState_cin?controllerState_take -> controllerState=controllerState_take;
	:: controllerState_cin?controllerState_produce -> controllerState=controllerState_produce;
		if
		// TRANSITION PRODUCER_SRS_1
		:: ((controllerState == controllerState_produce) && (producerState == producerState_empty) && (doorLock == doorLock_lock)) -> produceTimer_cout!produceTimer_running; producerState_cout!producerState_producing; 
		// TRANSITION PRODUCER_SRS_2
		:: ((produceTimer == produceTimer_timeout) && (controllerState == controllerState_produce) && (producerState == producerState_producing) && (doorLock == doorLock_lock)) -> producerState_cout!producerState_full; doorLock_cout!doorLock_unlock; 
		fi;
	:: producerState_cin?producerState_producing -> producerState=producerState_producing;
	:: producerState_cin?producerState_full -> producerState=producerState_full;
	:: producerState_cin?producerState_empty -> producerState=producerState_empty;
	:: action_cin?action_take -> action=action_take;
		if
		// TRANSITION PRODUCER_SRS_3
		:: ((controllerState == controllerState_produce) && (producerState == producerState_full) && (action == action_take) && (doorLock == doorLock_unlock)) -> producerState_cout!producerState_empty; doorLock_cout!doorLock_lock; 
		fi;
	:: action_cin?action_selectAmericano -> action=action_selectAmericano;
	:: action_cin?action_selectLatte -> action=action_selectLatte;
	:: action_cin?action_selectMocha -> action=action_selectMocha;
	:: action_cin?action_selectEspresso -> action=action_selectEspresso;
	:: action_cin?action_ok -> action=action_ok;
	:: action_cin?action_cancel -> action=action_cancel;
	:: doorLock_cin?doorLock_lock -> doorLock=doorLock_lock;
	:: doorLock_cin?doorLock_unlock -> doorLock=doorLock_unlock;
	:: produceTimer_cin?produceTimer_timeout -> produceTimer=produceTimer_timeout;
	:: produceTimer_cin?produceTimer_running -> produceTimer=produceTimer_running;
	// NO TRIG TRANSITION PRODUCER_SRS_4
	:: ((produceTimer == produceTimer_running)) -> produceTimer_cout!produceTimer_timeout; 
	od;
};

active proctype UniversalEnvironment(){
do
	::doorLock_cout?doorLock_unlock -> doorLock_cin!doorLock_unlock;
	::producerState_cout?producerState_producing -> producerState_cin!producerState_producing;
	::producerState_cout?producerState_empty -> producerState_cin!producerState_empty;
	::doorLock_cout?doorLock_lock -> doorLock_cin!doorLock_lock;
	::producerState_cout?producerState_full -> producerState_cin!producerState_full;
	::produceTimer_cout?produceTimer_timeout -> produceTimer_cin!produceTimer_timeout;
	::produceTimer_cout?produceTimer_running -> produceTimer_cin!produceTimer_running;
od;
}
trace{
	Q_0: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_0;
		::controllerState_cin?controllerState_pos -> goto Q_0;
		::doorLock_cin?doorLock_lock -> goto Q_0;
		::controllerState_cin?controllerState_select -> goto Q_0;
		::produceTimer_cin?produceTimer_timeout -> goto Q_2;
		::controllerState_cin?controllerState_produce -> goto Q_0;
	fi;
	Q_1: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_1;
		::controllerState_cin?controllerState_pos -> goto Q_1;
		::doorLock_cin?doorLock_lock -> goto Q_0;
		::controllerState_cin?controllerState_select -> goto Q_1;
		::controllerState_cin?controllerState_produce -> goto Q_1;
	fi;
	Q_2: if
		::doorLock_cin?doorLock_unlock -> goto Q_1;
		::controllerState_cin?controllerState_take -> goto Q_2;
		::controllerState_cin?controllerState_pos -> goto Q_2;
		::controllerState_cin?controllerState_select -> goto Q_2;
		::controllerState_cin?controllerState_produce -> goto Q_2;
	fi;

}
active proctype word(){
	controllerState_cin!controllerState_pos;

}
